# 问题描述

给你一个整数`x`, 如果`x`是一个回文整数, 返回`true`; 否则, 返回`false`

> **回文数**是指正序(从左向右)和倒序(从右向左)读都是一样的整数。

例如, `121`是回文, 而`123`不是

**示例1**:

**输入**: `x = 121`
**输出**: `true`

**示例2**:

**输入**: `x = -121`
**输出**: `false`
**解释**: 从左向右读, 为`-121`。从右向左读, 为`121-`。因此它不是一个回文数。

**示例3**:

**输入**: `x = 10`
**输出**: `false`
**解释**: 从右向左读, 为`01`。因此它不是一个回文数。

**提示**:

$-2^{31} \le x \le 2^{31} - 1$

# 解决问题

## 解法1: 转换为字符串

### 具体思路

&emsp;&emsp;利用C++的内置函数`to_string()`将`x`转换为字符串形式, 随后遍历字符串, 每次循环比对当前位置和末尾对应位置是否相同, 相同则继续比对, 直到遍历至字符串中间位置, 如果全部相同则返回`true`, 否则返回`false`。

### 代码实现

```C++
#include <iostream>
#include <string>

using namespace std;

bool isPalindrome(int x){
    string str = to_string(x);
    int len = str.length();

    for (int i = 0; i < len / 2; i++){
        if (str[i] != str[len - 1 - i]){
            return false;
        }
    }
    return true;
}
```

## 解法2

### 具体思路

&emsp;&emsp;根据回文数的性质, 我们可以直到回文数的首尾是相同的, 那么我们能不能通过反转`x`的后半部分, 将其与前半部分进行比较来进行判断呢?
&emsp;&emsp;当数字位数为偶数时, 其后半部分反转的数字位数与前半部分相同但当数字位数为奇数时, 前半(后半)部分的位数比后半(前半)部分多一位, 应该如何解决?
&emsp;&emsp;再次思考回文数的性质, 我们发现回文数位数为奇数时, 中间的数其实并不重要, 可以认为前半部分和后半部分都包含了这个数字, 因此我们只需要在判断时将前半(后半)部分减去一位数字即可

### 代码实现

```C++
#include <iostream>

using namespace std;

bool isPalindrome(int x){
    //首先对一些特殊情况进行处理
    //负数, 能被10整除的数不是回文数
    if (x < 0 || (x % 10 == 0 && x != 0)){
        return false;
    }
    //定义后半部分的数字
    int reserved_num = 0;
    while (x > reserved_num){
        reserved_num = reserved_num * 10 + x % 10;
        x /= 10;
    }
    return x == reserved_num || x == reserved_num / 10;
}
```

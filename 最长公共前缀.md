# 问题描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`

**示例 1**：

**输入**：`strs = ["flower","flow","flight"]`
**输出**：`"fl"`

**示例 2**：

**输入**：strs = ["dog","racecar","car"]
**输出**：""
**解释**：输入不存在公共前缀。

**提示**：

$1 \leq$ `strs.length` $\leq 200$
$0 \leq$ `strs[i].length` $\leq 200$
`strs[i]` 仅由小写英文字母组成

# 解决问题

## 解法1

### 具体思路

要求公共前缀, 即词组中每个单词都有的一段子串, 只需取其中任意一个字符串, 对词组中的其他字符串, 依次比对字符, 一旦不匹配, 则退出循环, 返回公共前缀

### 代码实现

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

string longestCommonPrefix(vector<string>& strs) {
    string str = strs[0];
    int size = str.size();
    int len = str.length();
    string res = "";
    for (int i = 0; i < len; i++){
        for (int j = 1; j < size; i++){
            if (str[i] != strs[j][i]){
                return res;
            }
        }
        res += str[i];
    }
    return res;
}
```

时间复杂度$O(N*M)$, 空间复杂度$O(1)$

## 解法2

### 具体思路

对于公共最长前缀, 我们可以不必对每个字符串都进行比较, 利用C++内置的sort函数, 将词组先进行排序, 那么除第一个和最后一个字符串之外的其他字符串必然拥有相同前缀, 这时只需要比较第一个和最后一个字符串即可

函数`sort()`: 对于两个字符串, 按照每个字符的ASCII码进行排序, 由于本题中字符串均为小写, 因此不存在大小写错误的问题

需要用到的函数:

- `sort()`
- `strs.begin(), strs.end()`: 迭代器, 分别指向vector数组的第一个和最后一个元素
- `strs.front(), strs.back()`: 返回vector数组的第一个和最后一个元素

### 代码实现

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

string longestCommonPrefix(vector<string>& strs) {
    sort(strs.begin(), strs.end());
    string res = "";
    string fir = strs.front();
    string las = strs.back();
    int len = min(fir.length(), las.length());
    for (int i = 0; i < len; i++){
        if (fir[i] == las[i]){
            res += fir[i];
            continue;
        }
        break;
    }
}
```

时间复杂度$O(N*M*\log{n})$, 空间复杂度$O(1)$

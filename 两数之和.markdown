# 问题描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值**  *​`target`​*  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1:**

> **输入**: **​`nums = [2,7,11,15], target = 9`​**
> **输出**:  **​`[0,1]`​**
> **解释**：因为 **​`nums[0] + nums[1] == 9`​**, 返回  **​`[0, 1]`​**

**示例 2:**

> **输入**: **​`nums = [3,2,4], target = 6`​**
> **输出**:  **​`[1,2]`​**
> **解释**: 因为 **`nums[1] + nums[2] == 6`**, 返回 **`[1, 2]`**

**示例 3:**

> **输入**: `nums = [3,3], target = 6`
> **输出**: `[0,1]`
> **解释**: 因为 **`nums[0] + nums[1] == 6`**, 返回 **`[0, 1]`**

**提示：**

* $$2 <= nums.length <= 10^4$$
* $$-10^9 <= nums[i] <= 10^9$$
* $$-10^9 <= target <= 10^9$$
* $$只会存在一个有效答案$$

# 解决问题

## 解法1: 枚举法

### 具体思路

&emsp;&emsp;通过双重for循环遍历数组`nums`, 直到出现满足条件的下标, 直接返回由该下标组成的数组, 由于题目保证有解, 因此无需考虑特殊情况

### 代码实现

``` C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> twoSum(vector<int> nums, int target){
    for (int i = 0; i < nums.size(); i++){
        for (int j = 0; j < nums.size(); j++){
            if (nums[i] + nums[j] == target && i != j){
                return {i, j};
            }
        }
    }
}
```

### 复杂度分析

&emsp;&emsp;上述嵌套循环在最坏的情况下需要遍历$n*n = n^2$次, 时间复杂度为$O(n^2)$, 空间复杂度为$\Theta(1)$, 那么, 能否进一步优化呢?

### 代码优化

&emsp;&emsp;再次审视题目和代码, 可以发现, 当外层循环遍历到`i`时, 内层循环不必再从`0`开始, 因为这些情况已经在`0-i`的循环时处理过了, 又因为题目要求元素不能重复, 所以内层循环可以从`i+1`开始, 而外层循环需要相应改成`i < nums.size() - 1`, 避免数据溢出

**优化后的代码**

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> twoSum(vector<int> nums, int target){
    for (int i = 0; i < nums.size() - 1; i++){
        for (int j = i + 1; j < nums.size(); j++){
            if (nums[i] + nums[j] == target){
                return {i, j};
            }
        }
    }
    return {}; //C++要求非void函数必须有返回值
}
```

上述代码虽然优化了时间复杂度, 但时间复杂度还是很高, 有没有一种算法, 可以使代码的时间复杂度为$O(n)$呢?

## 解法2: 哈希表(字典)

### 前置知识

1. **字典**:
   一种数据存储形式, 通过键: 值对的方式将数据一一对应, 其中键是唯一的, 值可以重复

2. **C++中的unordered_map**：
   这是C++的一种实现字典功能的容器, 下面将介绍它的功能与需要用到的函数:
    * `unordered_map<key_type, value_type> map_name;`: 构造函数, `key_type`为键的类型, `value_type`为值的类型
    * `operator[key]`: 可以通过[key]来访问字典中key对应的value
    * `find(key)`: 查找以key为键的键值对, 并返回指向该键值对的正向迭代器, 若key不存在, 则返回指向哈希表最后一个键值对之后的迭代器(`my_map.end()`)
    * `auto it = my_map.find(key); it->second`: it为指向哈希表某个键值对的迭代器, 通过运算符`->`可以访问it对应的键值对, `it->first`访问key, `it->second`访问value

### 具体思路

&emsp;&emsp;我们可以遍历`nums`, 每次遍历时, 检查当前元素与哈希表中的元素之和是否等于`target`, 如果哈希表中没有与之匹配的元素, 则将`j`和`nums[j]`作为新的键值对加入哈希表中, 直到匹配成功
&emsp;&emsp;注意: 顺序不能颠倒, 必须先判断, 再加入, 否则会出现这种情况: `target`和`nums[j]`分别为4和2, 若先将`nums[j]`加入哈希表, 则会出现$2+2=4$, 返回`[1, 1]`(假设`j`为1), 这与题目的要求(元素不能重复)冲突
&emsp;&emsp;特殊情况处理: 当`j = 0`时, 由于哈希表中没有元素, 则应直接加入哈希表中

### 过程演示

假设`nums = {3, 1, 4, 1, 5, 9}, target = 9`

1. 对`nums[0] = 3`, 由于哈希表中没有元素, 直接将其加入哈希表中
   哈希表状态:

   |键|值|
   |---|---|
   |3|0|

2. 对`nums[1] = 1`, 查询哈希表中是否有值为$9-1=8$的键, 没有, 则加入哈希表中
   哈希表状态:

   |键|值|
   |---|---|
   |3|0|
   |1|1|

3. 对`nums[2] = 4`, 重复上述过程, 没有$9-4=5$的键值对, 加入哈希表
   哈希表状态:

   |键|值|
   |---|---|
   |3|0|
   |1|1|
   |4|2|

4. 重复上述过程, 当`nums[4] = 5`时, 哈希表中有键值对`{2, 4}`满足$4+5=9$, 因此返回`{2, 4}`

经过上面的演示, 相信你对哈希表已经有初步了解了, 我们应该有这样的疑问: 每次循环时查询哈希表难道不是对哈希表进行遍历吗? 为什么这样的查找时间复杂度为$O(1)$呢?
就数组来说, 如果我们想要在不知道下标的情况下查找数组中的某一个值, 只能通过遍历整个数组的方法查找, 对于哈希表, 它将自身存储的数据以键值对的形式进行映射, 并且每个键都是独立不重复的, 因此, 我们在需要查找某个元素时, 只需要对键进行查询即可, 即不需要遍历整个哈希表, 只需要访问一次内存就能获取需要的元素, 因此时间复杂度为$O(1)$

### 代码实现

```C++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> twoSum(vector<int> nums, int target){
    unordered_map<int, int> unmap;
    for (int j = 0; j < nums.size(); j++){
        auto it = unmap.find(target - nums[j]);
        if (it != unmap.end()){
            return {it->second, j};
        }
        unmap[nums[j]] = j;
    }
    return {}; //C++要求非void函数必须有返回值
}
```

时间复杂度为$O(n)$, 空间复杂度为$\Theta(1)$

# 问题描述

给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 每个右括号都有一个对应的相同类型的左括号。

**示例 1**：

**输入**：`s = "()"`
**输出**：`true`

**示例 2**：

**输入**：`s = "()[]{}"`
**输出**：`true`

**示例 3**：

**输入**：`s = "(]"`
**输出**：`false`

**示例 4**：

**输入**：`s = "([])"`
**输出**：`true`

**提示**：

- $1 \leq s.length \leq 10^4$
- `s` 仅由括号 `'()[]{}'` 组成

# 解决问题

## 解法1

### 前置知识

- 栈
  栈(stack)是一种仿造C++底层数组结构设计的数据结构, 主要特点是**先进后出**
  - 主要用法
    - 构造函数: `stack<type> stack_name;`, 创建空栈
    - `stack_name.push(element);`, 将`element`放入栈中
    - `stack_name.pop();`, 弹出栈顶元素
    - `stack_name.top();`, 获得栈顶元素
    - `stack_name.empty();`, 判断栈是否为空, 为空返回`true`, 否则返回`false`

### 思路

对字符串进行遍历, 每当遇到左括号时, 就将右括号压入栈中, 当遇到右括号时, 对栈进行判断, 如果栈不为空且栈顶元素为对应的右括号, 则将栈顶元素弹出, 否则直接返回`false`

原因: 在问题描述中, 括号必须以正确的顺序闭合, 即不会出现如`"([)]"`这样的输入, 因此在遍历字符串时, 当遍历到`'('`时, 将`')'`压入栈中, 当遍历到`')'`时, 如果栈顶元素不为`')'`, 则说明右括号没有闭合


### 代码实现

```C++
#include <iostream>
#include <stack>

using namespace std;

bool isValid(string s) {
    stack<char> st;
    for (char c : s){
        if (c == '('){
            st.push(')');
        }
        else if (c == '['){
            st.push(']');
        }
        else if (c == '{'){
            st.push('}');
        }
        else if (st.empty() || c != st.top()){
            return false;
        }
        else{
            st.pop();
        }
    }
    return st.empty();
}
```

时间复杂度$O(N)$, 空间复杂度$O(N)$

## 解法2

### 前置知识

哈希表: 详见[哈希表](两数之和.markdown#解法2-哈希表字典)

### 思路

将**解法1**中的`if-else`语句使用哈希表进行替换

### 代码实现

```C++
#include <iostream>
#include <stack>
#include <unordered_map>

using namespace std;

bool isValid(string s) {
    unordered_map<char, char> mp = {
        {'(', ')'},
        {'[', ']'},
        {'{', '}'}
    };
    stack<char> st;
    for (char c : s){
        if (mp.count(c)){
            st.push(mp[c]);
        }
        else if (st.empty() || c != st.top()){
            return false;
        }
        else{
            st.pop();
        }
    }
    return st.empty();
}
```

时间复杂度和空间复杂度相较**解法1**没有变化, 但运行时间加快了

解法1用时$3ms$, 解法2用时$0ms$, 说明使用C++内置库的性能优化能好

# 问题描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

![链表示例](merge_ex1.jpg)

**示例 1**：

**输入**：`l1 = [1,2,4], l2 = [1,3,4]`
**输出**：`[1,1,2,3,4,4]`

**示例 2**：

**输入**：`l1 = [], l2 = []`
**输出**：`[]`

**示例 3**：

**输入**：`l1 = [], l2 = [0]`
**输出**：`[0]`

**提示**：

- 两个链表的节点数目范围是 `[0, 50]`
- $-100 \leq Node.val \leq 100$
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## 链表定义

```C++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
}
```

# 解决问题

## 对链表定义的解释

- `int val`: 存储当前节点的值
- `ListNode *next`: 存储指向下一个节点的指针
- `ListNode() : val(0), next(nullptr) {}`: 默认构造函数, 构造只有一个节点, 值为0的链表
- `ListNode(int x) : val(x), next(nullptr) {}`: 构造只有一个节点, 值为x的链表
- `ListNode(int x, ListNode *next) : val(x), next(next) {}`: 构造一个节点, 值为x, 指向下一个节点的指针为`next`的链表

## 解法1

### 思路

通过列表的结构体定义, 其中存储了当前节点的值`val`和指向下一个节点的指针`next`, 我们需要比较两链表节点的大小, 如果链表1节点1的值大于链表2节点1的值, 则调用链表2的next指针, 将链表2的值再次与链表1节点1的值比较(即递归调用函数), 随后赋值给链表1的next指针, 最后返回链表1即可, 因为链表2的所有节点已被插入到链表1中, 反之, 如果链表2大于链表1同理

### 代码实现

```C++
#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2){
    //对特殊情况进行处理
    if (list1 == nullptr){
        return list2;
    }
    else if (list2 == nullptr){
        return list1;
    }
    else if (list1->val > list2->val){
        list2->next = mergeTwoLists(l1, l2->next);
        return list2;
    }
    else{
        list1->next = mergeTwoLists(l1->next, l2);
        return list1;
    }
}
```
